# 技术总结

## 线程同步
线程同步的四项原则，按重要性排列：
1. 首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑不可修改的对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。
2. 其次是使用高级的并发编程构件，如TaskQueue、Producer-Consumer Queue、 CountDownLatch等。
3. 最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。
4. 除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。

### 互斥锁
使用RAII（资源获取即初始化）技术，对MutexLock初始化和析构进行处理。MutexLockGuard对象初始化的时候加锁，析构的时候解锁。
```
class MutexLockGuard : noncopyable
{
public:
  explicit MutexLockGuard(MutexLock& mutex) : mutex_(mutex)
  {
    mutex_.lock();
  }

  ~MutexLockGuard()
  {
    mutex_.unlock();
  }

private:
  MutexLock& mutex_;
};
```
### 条件变量
1. Blockingqueue

关于封装条件变量的一般使用，假设我们要实现简单的容量无限的BlockingQueue，可以这样写：
```
MutexLock mutex;
Condition cond(mutex);
std::deque<int> queue;

int dequeue()
{
    MutexLockGurad lock(mutex);
    while(queue.empty())
    {
        cond.wait();//这一步会释放mutex并进入等待，这两个操作是原子的
        //wait()返回后，会自动重新加锁
    }
    assert(!queue.empty());
    int top = queue.front();
    queue.pop_front();
    return top;
}

void enqueue(int x )
{
    MutexLockGurad(mutex);
    queue.push_back(x);
    cond.notify();
}
```
